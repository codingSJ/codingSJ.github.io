---
title: "JAVA_클래스"
layout: single
author_profile: false
read_time: true
comments: true
share: true
related: true
categories:
- JAVA
description: 클래스의 기본적인 개념에 대해 알아보자.
toc: true
toc_sticky: true
toc_label: 목차
---

### 0. 이 글의 목적

- 객체 지향 프로그래밍을 이해한다.
- 객체, 클래스, 인스턴스에 대한 개념과 그 차이를 이해한다.





### 1. 객체 지향 프로그래밍

> 1-1. 객체 지향 프로그래밍( OOP: Object Oriented Programming )의 정의

레고 만들 때를 생각해보면, 처음에 작은 부품을 조립하는 것부터 시작해 하나씩 조립해 결국 하나의 큰 완성품을 만든다. 객체 지향 프로그래밍은 하나의 프로그래밍 패러다임으로, state(상태)와 behavior(행위)를 가진 객체를 가지고 로직을 이루는 프로그래밍 방식이다. 즉 객체 지향 프로그래밍은 객체를 만드는 것이 그 시작과 끝이고, 따라서 객체 지향 프로그래밍을 이해하는 첫 단계는 객체가 무엇인가를 아는 것이다.



> 1-2. 객체, 클래스, 인스턴스란?

그렇다면 객체란 무엇일까? 간단히 말하면 객체는 실존하거나 개념적으로 생각할 수 있는 것이고, 조금 자세히 말하면 $객체란 자신의 속성( state )과 동작( behavior )을 가지며, 다른 것과 식별 가능한 것$ 이다. 자바에서는 특히 속성과 동작을 각각 필드( field )와 메소드( method )라 부른다. 모니터를 사기 위해 전자기기 매장을 갔다고 해보자. 그 곳에는 모니터뿐만 아니라 마우스, 키보드 등이 다양하게 존재할 것이다. 즉 수많은 객체가 존재한다. 그리고 매장 창고에는 똑같은 모니터가 여러 개 갖고 있을 것이다. 즉 동일한 객체가 생성될 수 있는 것이다. 그렇다면, 이 객체를 생성하기 위해 필요한 정보들을 갖고 있는 설계도가 있을 것이다. 이런 설계도의 역할에 해당되는 것이 클래스이다. 그리고 그 설계도에는 모니터의 기능, 부품명 등 모니터와 관련된 내용들이 적혀있을 것이다. 클래스와 객체에 대해 정리하면 다음과 같다.

- 클래스( Class )란
  - $객체를 만들기 위한 설계도 혹은 틀$
  -  연관된  필드와 메소드를 포함

- 객체( Object )란
  - $클래스에 적혀있는대로 생성된 실체$
  - 속성과 동작을 가지고 있으며, 자바에서는 속성을 필드, 동작을 메소드라 호칭
  - **클래스로부터 만들어진 객체를 해당 클래스의 인스턴스( instance )라고 한다.​**



이제 클래스와 객체는 구분이 되었을 것이라 생각한다. **'클래스로부터 만들어진 객체를 해당 클래스의 인스턴스( instance )라고 한다.'** 여기서의 인스턴스는 무엇일까? 그리고 객체와 어떤 차이가 있을까?

인스턴스와 객체는 완전히 다른 것은 아니다. 객체와 인스턴스 모두 *"어떤 클래스의 설계대로 생성된 실체"*를 가리킨다. 둘의 차이는 어느 것을 강조하느냐이다. **객체는 실체 그 자체를 강조하는 반면 인스턴스는 클래스와의 관계** 를 강조한다. 다시 정리하면 다음과 같다.

- 클래스( Class )란
  - **객체를 만들기 위한 설계도 혹은 틀​**
  -  연관된  필드와 메소드를 포함

- 객체( Object )란
  - **클래스에 적혀있는대로 생성된 실체​**
  - 속성과 동작을 가지고 있으며, 자바에서는 속성을 필드, 동작을 메소드라 호칭
  - **클래스로부터 만들어진 객체를 해당 클래스의 인스턴스( instance )라고 한다.​**
- 인스턴스( Instance )란
  - **클래스의 설계대로 생성된 실체​** 로 "클래스 A의 인스턴스" 식으로 표현한다.
  - 객체는 클래스의 인스턴스이다.



> 1-3. 객체의 상호작용

모든 현실에서의 상황은 객체 간의 상호작용에 의해 발생한다. 사람이 차의 엑셀을 밟으면 차는 앞으로 가고 사람의 위치를 바꿔준다. 프로그램 또한 마찬가지다. 여러 객체들이 각각 독립적으로 존재하며 서로 간의 상호작용을 통해 프로세스가 진행된다. $객체가 다른 객체와 상호작용한다는 것은 하나의 객체가 다른 객체를 사용한다는 뜻이다.$ 앞에서 언급한 객체의 구성 중 메소드가 바로 객체 간의 상호작용 수단이다. 객체 A가 객체 B의 메소드를 호출함으로써 B의 기능을 사용할 수 있다. 우리가 반 평균을 구하기 위해 계산기를 사용한다고 할 때, 학생들의 점수를 계산기에 입력해 덧셈을 한 후에 학생 수로 나눠 평균을 구한다. 인간은 계산기의 덧셈 기능과 나눗셈 기능을 사용하기 위해 학생들의 점수와 학생 수를 매개값으로 넘겨주었고, 그 결과로 계산기는 반 평균이라는 값을 인간에게 전달해주었다. 이렇게, 객체의 상호작용은 객체 간의 $메소드 호출$을 의미하며 매개값과 리턴값을 통해서 데이터를 주고 받는다.



> 1-4. 객체 간의 관계

객체는 독립적으로 사용될 수 있지만, 대부분 다른 객체와 관계를 맺어 사용된다. 객체 간의 관계로는 **집합 관계, 사용 관계, 상속 관계**가 있다.

- 집합 관계
  - 부품과 완성품의 관계
  - ex) 타이어와 자동차
- 사용 관계
  - 객체 간의 상호작용을 말하며 한 객체가 다른 객체의 메소드를 호출해 원하는 결과를 얻어낸다.
- 상속 관계
  - 상위(부모) 객체를 기반으로 하위(자식) 객체를 생성하는 관계



> 1-5. 객체 지향 프로그래밍의 특징: 캡슐화, 상속, 다형성

이렇게 객체에 대해 어느 정도 개념이 잡힌 상태로 객체 지향 프로그래밍을 다시 생각해보자. 객체 지향 프로그래밍의 시작과 끝은 결국 객체를 만드는 것이라 했다. 그래서 객체 지향 프로그래밍은 $캡슐화, 상속, 다형성$​ 등의 특징을 갖는다.

- 캡슐화( Encapsulation )
  - 2가지 측면이 있다. **1) 객체의 필드와 메소드를 하나로 묶고, 2) 실제 구현 내용의 일부를 감추는 것을 뜻한다.​**
  - 객체 A를 사용하고자 하는 외부 객체 B가 있을 때, B는 A가 보여지도록 허용한 필드와 메소드만 사용가능하다.
  - **캡슐화로 객체를 감추는 이유는 객체를 외부 객체로부터 보호하기 위함이다.​** 우리가 ATM을 이용할 때, ATM 돈 보관함의 열쇠나 비밀번호를 모르더라도 출금과 입금이 가능하다. 반대로 ATM의 비밀번호가 노출된다면 여러 위험한 상황이 있을 것이다. 이처럼 ATM은 우리에게 출금과 입금에 관련된 것은 허용하지만, 보안과 관련된 내용은 우리에게 노출시키지 않는다.
  - 이처럼 객체는 자신의 필드나 메소드 중 외부 객체가 사용할 수 있는 것과 보호할 것을 구분해 결정해야 한다. 그리고 이런 구분은 $접근 제한자( Access Modifier )$에 의해 결정된다.
  - ![img](https://t1.daumcdn.net/cfile/tistory/2614B34D5874E1D809)
  
- 상속( Inheritance )
  - 상속이란 주로 부모가 자식에게 재산 등을 물려주는 행위이다. 객체 간의 상속도 이와 크게 다르지 않다. 객체 간의 상속이란, **상위 객체의 필드와 메소드를 하위 객체에게 물려줌으로써 하위 객체가 사용할 수 있도록 해주는 것이다.**
  - 상속은 코드의 재사용성을 높인다는 장점이 있다.
  - 하위 객체는 상위 객체에게서 물려받은 필드나 메소드에 변화를 주지 않고 사용할 경우 선언하지 않고도 사용할 수 있다.
  - 하위 객체가 상위 객체에게서 물려받은 필드나 메소드에 변화를 주고 사용하고 싶은 경우 $오버라이딩$을 사용해 재정의할 수 있다.
  - ![img](https://t1.daumcdn.net/cfile/tistory/2503F14C5874E25D3F)

- 다형성( Polymorphism )

  - 다형성이란 **같은 타입이지만 실행 결과가 다양한 객체를 이용할 수 있는 성질**을 말한다. 조금 풀어서 말하면 다형성은 하나의 타입에 여러 객체를 대입해 다양한 기능을 사용할 수 있도록 해준다.

  - 자바는 다형성을 위해 상위 클래스 또는 인터페이스의 타입 변환을 허용한다. 상위 타입은 모든 하위 객체를 대입할 수 있고, 인터페이스 타입에는 모든 구현 객체가 대입될 수 있다.

    - 상위 타입을 하위 객체에 대입하는 경우

    - ```java
      class Animal {
          void barking(){
              System.out.println("animal~~~");
          }
      }
      
      
      class Cat extends Animal
      {
          int age = 10;
      
          @Override
          void barking(){
              System.out.println("cat~~");
          }
      
          public static void main(String[] args) {
              Cat cat = new Cat();
            	//상위 클래스 변수 = 하위 클래스 타입
              Animal animal = cat;
              
            	animal == cat // true
            
           		animal.barking();	// cat~~이 출력됨
              int animalAge = animal.age;	//컴파일 오류. 상위 객체는 상위 객체에서 선언된 필드 및 메소드만 참조할 수 있음
              
          }
      }
      ```

    - 위의 예제를 보면, '상위 클래스 변수 = 하위 클래스 타입;' 의 선언이 가능하다. Cat 클래스는 Animal 클래스를 상속받았기 때문에 animal은 Cat 객체를 참조할 수 있다.peSkeb-gyskyw-jumwu5

  - ![img](https://t1.daumcdn.net/cfile/tistory/270AA24C5874E31903)



#### Reference

https://gmlwjd9405.github.io/2018/09/17/class-object-instance.html

https://opentutorials.org/course/1223/5399

https://www.ijemin.com/blog/오브젝트와-인스턴스의-차이-difference-between-obect-and-instance

<이것이 자바다>