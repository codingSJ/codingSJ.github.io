---
title: "IoC Container 란"
layout: single
author_profile: true
read_time: true
comments: true
share: true
related: true
categories:
- SPRING
description: 스프링의 코어 개념인 IoC Container에 대해 알아본다.
toc: true
toc_sticky: true
toc_label: 목차
---

### 0. 이 글의 목적

- DI와 더불어 스프링의 또 다른 코어 개념인 IoC 컨테이너를 이해한다.






### 1. IoC 컨테이너의 개념

> 1-1. IoC 컨테이너의 개념

DI에 대한 개념을 공부하면서, DI가 객체 A를 만들기 위해 필요한 부품 B를 조립해주는 과정이라는 것을 알았고 스프링이 개발자를 대신해 DI해준다는 것을 배웠다. 이제 DI와 더불어 스프링의 또 다른 개념인 IoC 컨테이너에 대해 배워보려 한다.

레고 조립을 생각해보면, 부품만 가지고 있다해서 조립이 가능하지 않다. 어떤 부품들을 모아 어떤 방식으로 조립해야 한다는 설명서 또한 필요하다. 스프링 또한 마찬가지다. 객체들만 주면 스프링은 조립을 제대로 할 수 없다. 설명서 또한 같이 알려줘야하는데, xml 파일을 이용하거나 annotation을 사용해 설명서를 알려줄 수 있다. 이 부분은 후에 공부해보자.

그래서 결국 부품과 설명서를 스프링에게 전달해주면, 스프링이 이리저리 조립을 해준다. 그리고 이런 조립된 완성품들을 보관해야 할 그릇이 필요한데, 이 개념이 IoC 컨테이너이다. 즉 IoC 컨테이너는 부품(Dependency)이 담겨있는 컨테이너, 다시 말해 Dependency 컨테이너이다. 그럼 IoC의 의미는 무엇일까?



> 1-2. IoC(Inversion of Control) - 제어의 역전

레고 조립을 생각해보자. 조립의 끝은 하나의 완성품이지만, 그 시작은 가장 작은 레고 조각이다. 작은 부품들을 모아 조금 큰 부품을 만들고, 조금 큰 부품들을 모아 더 큰 부품을 만들고, 결국 더 큰 부품들을 모아 하나의 완성품을 만든다. 여기서 주목할 점은, 하나의 완성품을 만드는데 있어 그 시작은 가장 작은 조각이라는 것이다.



```java
//작은 부품에서 큰 부품으로
class A
{
    private B b;

    public void setB(B b){
      this.b = b;
    }
}

class B
{
  	...
}


B b = new B();
A a = new A();
a.setB(b);
```

위의 예시를 보면 A를 만들기 위해서는 우선 B가 있어야 한다. 즉 가장 작은 부품인 B를 만들고, B를 사용하는 A를 만든다. 하지만 다음 방법은 어떨까?

```java
//큰 부품에서 작은 부품으로
class A
{
    private B b;

    public A(){
        b = new B();
    }
}

class B
{
  	...
}

A a = new A();
```

가장 큰 부품인 A를 만들면, B가 자동으로 생성된다. 즉 가장 큰 부품에서부터 시작한다.



스프링의 DI는 큰 객체부터 시작되는 것이 아니라 작은 객체부터 시작된다. 즉 작은 객체부터 큰 객체로 이어지는, 역순(=Inversion of Control)으로 의존성을 주입한다.

따라서, IoC 컨테이너는 의존성을 갖고 있는 객체들을 모아둔 컨테이너인데, 가장 작은 객체부터 의존성 주입을 시작하는 컨테이너를 말한다.





#### Reference

